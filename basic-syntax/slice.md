# 슬라이스 (Slice)

슬라이스는 큰 컬랙션의 일부(혹은 전체)를 보여주는 뷰(view)입니다:

```rust
fn main() {
    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];
    println!("a: {a:?}");

    let s: &[i32] = &a[2..4];
    println!("s: {s:?}");
}
```

* 슬라이스는 다른(슬라이스 된) 타입으로부터 데이터를 ’빌려’옵니다.
* 질문: `a[3]`을 수정하면 무슨 일이 있어날까요?

<details>

<summary>발표자 노트</summary>

* 슬라이스는 우선 `a`를 빌린다음, 시작과 끝 인덱스를 브래킷(`[]`)안에 지정해서 만듭니다.
* 슬라이스가 인덱스 0부터 시작한다면 시작 인덱스는 생략 가능합니다. 즉 `&a[0..a.len()]`와 `&a[..a.len()]` 는 동일합니다.
* 마지막 인덱스도 생략 가능합니다. 그래서 `&a[2..a.len()]` 와 `&a[2..]`는 동일합니다.
* 따라서 전체 배열에 대한 슬라이스는 `&a[..]`가 됩니다.
* `s`는 `i32`들로 이루어진 슬라이스에 대한 참조입니다. `s`의 타입(`&[i32]`)에 배열의 크기가 빠져있음에 주목하시기 바랍니다. 즉, 슬라이스를 이용하면 다양한 길이의 데이터를 다룰 수 있습니다.
* 슬라이스는 항상 다른 객체로부터 ‘빌려’ 옵니다. 이 예시에서 객체 `a`는 슬라이스 `s`보다 더 오래 살아 있어야만 합니다.
* `a[3]`의 값을 바꿀 수 있냐는 질문은 좋은 질문입니다. 여기에 대한 답은 `a`와 `s`를 통해 데이터를 읽을 수는 있지만 수정할 수는 없으며, 이는 메모리 안전을 위해서라는 것입니다. 왜 그런지에 대한 좀더 구체적인 답은 빌림 검사 부분에서 자세히 설명합니다.

</details>

<details>

<summary>놀미 노트</summary>

* 슬라이스는 연속된 메모리의 조각입니다. 연속된 메모리가 아니면 슬라이스로 만들 수 없습니다. 배열과 Vec는 가장 기본적인 타잎이고 가장 많이 쓰입니다. 이를 통합해서 슬라이스에 대해 다양한 트레이트를 구현하면 막강한 기능을 얻을 수 있습니다. 예를 들어 다음에 살펴볼 String과 str의 경우가 슬라이스의 통합 능력을 활용한 예입니다.

</details>
