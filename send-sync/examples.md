# 예제 (Examples)

## Send + Sync

여러분이 다루게 될 대부분의 타입은 `Send + Sync`입니다:

* `i8`, `f32`, `bool`, `char`, `&str`, …
* `(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, …
* `String`, `Option<T>`, `Vec<T>`, `Box<T>`, …
* `Arc<T>`: 참조 카운트 조작을 아토믹 하기 때문에 스레드 안전함.
* `Mutex<T>`: 값을 접근하기 위해 뮤택스를 잠궈야 하기 때문에 스레드 안전함.
* `AtomicBool`, `AtomicU8`, …: 값을 접근할 때 특별한 아토믹 명령어들을 사용합니다.

제네릭 타입은 일반적으로 타입 파라메터가 `Send + Sync`이면 `Send + Sync` 입니다.

## Send + !Sync

아래 타입들은 다른 스레드로 이동될 수 있지만 내부적으로 값이 변경될 수 있기 때문에 스레드 안전하지 않습니다:

* `mpsc::Sender<T>`
* `mpsc::Receiver<T>`
* `Cell<T>`
* `RefCell<T>`

## !Send + Sync

아래 타입들은 스레드 안전하지만 다른 스레드로 이동될 수 없습니다:

* `MutexGuard<T>`: 내부적으로, 운영체제가 제공하는 primitive를 사용하는데, 이 primitive는 생성된 스레드에서 해제가 이루어져야 합니다. (_역주_: 그래서 다른 스레드로 옮길 수 없습니다.)

## !Send + !Sync

아래 타입들은 스레드 안전하지도 않고 다른 스레드로 이동될 수도 없습니다:

* `Rc<T>`: `Rc<T>` 는 아토믹하지 않은 방식으로 참조 카운트를 조작하는 `RcBox<T>`를 참조합니다.
* `*const T`, `*mut T`: 러스트는 포인터가 스레드 안전하지 않다고 가정합니다.

Send, Sync도 러스트에서 처음 보는 개념입니다. C++에서는 락으로 안전하게 걸고 처리하거나 atomic을 사용한다고 생각합니다. 러스트에서는 Send, Sync 트레이트로 락 없이 처리할 수 있는 범위를 확장합니다.&#x20;

