# 러스트의 메모리 관리

러스트의 메모리 관리는 지금까지 설명한 방식들을 혼합해서 사용합니다:

* 자바처럼 안전하고 정확합니다. 하지만 GC는 없습니다.
* 다양한 추상화를 제공합니다: 단일 포인터, 참조 카운트, 아토믹(atomic) 참조 카운트.
* C++ 처럼 범위(스코프) 기반입니다. 하지만 컴파일러가 훨씬 더 엄격합니다.
* 사용자는 상황에 따라 적합한 추상화를 선택할 수 있습니다. 그 중에는 C 언어 처럼 런타임 오버헤드가 없는 것도 있습니다.
* 러스트는 소유권을 언어 차원에서 명시적으로 모델링 함으로써 이를 이룹니다.

<details>

<summary>발표자 노트</summary>

이 시점에서 그게 어떻게 가능하냐는 질문이 있으면, 러스트에서 이 작업은 일반적으로 Box, Vec, Rc 또는 Arc와 같은 RAII 타입에 의해 처리된다고 답변할 수 있습니다. 이들은 다양한 방법을 통해 소유권과 메모리 할당에 대한 구체적인 내용을을 캡슐화하여, C 언어였다면 발생할 수 있었을 다양한 에러를 막습니다.

소멸자에 대한 질문도 있을 수 있습니다. Drop 트레이트가 답입니다.

</details>

<details>

<summary>놀미 노트</summary>

* 소유권을 중심으로 동작합니다. 소유권이 사라지면 Drop이 호출됩니다.
* Box, Vec, Rc, Arc 모두 Drop할 때 힙 메모리를 해제합니다.

</details>
