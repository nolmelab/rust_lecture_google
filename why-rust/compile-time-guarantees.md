# 컴파일할 때 보장하는 것들 (Compile Time Guarantees)

컴파일 시 정적 메모리 관리:

* 초기화되지 않는 변수가 없습니다.
* 메모리 누출 없음(_거의_. 강의참조노트 참고.)
* 메모리 이중 해제가 원천적으로 불가능 합니다.
* 메모리 해제 후 사용이 원천적으로 불가능 합니다.
* `NULL`포인터는 없습니다.
* 뮤텍스를 잠궈 놓고 여는 것을 잊는 실수를 할 수 없습니다.
* 스레드간 데이터 레이스를 막아줍니다.
* 반복자가 갑자기 무효화 되는 경우가 없습니다.

<details>

<summary>발표자 노트</summary>

(안전한) 러스트에서도 메모리 누출이 발생할 수 있는 몇 가지 경우가 있습니다:

* [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak)을 이용하여 포인터를 의도적으로 누출시킬 수 있습니다. 이를 이용해서 런타임이 생성하고 런타임이 크기를 정한 정적 변수를 가져올 수 있습니다.
* [`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn.forget.html)을 사용하여 컴파일러가 값에 대해 “잊도록” 만들 수 있습니다(소멸자가 실행되지 않음을 의미합니다).
* `Rc` 또는 `Arc`를 사용하여 실수로 [순환참조](https://doc.rust-lang.org/book/ch15-06-reference-cycles.html)를 생성할 수도 있습니다.
* 컬렉션을 무한정 채우는 것을 메모리 누출로 간주할 수도 있지만, 러스트는 이를 보호하진 못합니다.

본 강의에서는 “메모리 누출 없음“을 “우발적인 메모리 누출 없음“으로 이해해야 합니다.

</details>

<details>

<summary>놀미 노트</summary>

* 그렇다고 들으면 그런가 보다하고 지나가기 쉽습니다. 실제 이런 기능들에 익숙해지면 확신을 갖고 컴파일러에 기대어 코딩을 해나갈 수 있습니다.
* 러스트 코드에서 unsafe 코드들을 라이브러리 내부에서 많이 보게 되는데 오히려 안전하게 사용하지 않기가 어렵습니다. 이런 면은 시스템 프로그래밍 뿐만 아니라 성능이 필요한 게임 서버나 다른 애플리케이션 개발에 아주 큰 도움이 될 것입니다. 그래서, 대세 언어가 되리라 믿습니다.
* 컴파일러의 안정성 보장을 우회해서 코딩하려면 노력이 필요합니다. 이미 라이브러리 코드, 다른 뛰어난 크레이트들에서 확립된 방법들이 있으므로 필요시 찾아서 익혀 나가면 됩니다.

</details>
