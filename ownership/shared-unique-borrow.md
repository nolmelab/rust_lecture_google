# 공유와 고유 빌림

러스트에서는 값을 빌릴 때 다음과 같은 제약조건이 있습니다:

* 한번에 하나 이상의 `&T` 값을 가지거나, _또는_
* 정확히 하나의 `&mut T` 값만을 가질 수 있습니다.

```rust
fn main() {
    let mut a: i32 = 10;
    let b: &i32 = &a;

    {
        let c: &mut i32 = &mut a;
        *c = 20;
    }

    println!("a: {a}");
    println!("b: {b}");
}
```

<details>

<summary>발표자 노트</summary>

* 위 코드 컴파일 되지 않습니다. 왜냐하면 `c`는 `a`를 가변 변수로 빌렸고, 이와 동시에 `b`는 `a`를 불변 변수로 빌렸기 때문입니다.
* `b`에 대한 `println!` 구분을 `c`가 있는 범위 앞으로 이동하면 컴파일이 됩니다.
* 이렇게 바꾸면, 컴파일러는 `c`가 `a`를 가변 변수로 빌리기 전에만 `b`가 사용된다는 것을 확인할 수 있습니다. 빌림 검사기의 이러한 기능을 “non-lexical lifetime” 이라고 합니다.
  * 단순히 스코프만 보면 `b`의 수명은 `main`함수의 전체라고 생각할 수 있습니다. 때문에 `c`의 블록 안에서는 `a`에 대한 가변 빌림과 불변 빌림이 동시에 존재하는 것 처럼 보이며, 이는 위 제약 조건을 위반하는 것으로 생각할 수 있습니다. 그러나 컴파일러는 `b`가 `c`블록이 시작되기 전에만 사용된다는 점을 적극 활용해서 `b`의 수명을 `c`블록의 시작 전으로 줄입니다. 그러면 `b`와 `c`의 수명은 겹치지 않고, 따라서 제약 조건을 위반하지 않습니다.

</details>
