# 허상 참조 (Dangling Reference)

러스트는 허상(dangling) 참조를 컴파일러 단계에서 찾아내고 금지합니다:

```rust
fn main() {
    let ref_x: &i32;
    {
        let x: i32 = 10;
        ref_x = &x;
    }
    println!("ref_x: {ref_x}");
}
```

* 참조는 어떤 값을 “빌리는” 것입니다.
* 러스트는 참조 대상의 값이, 그 값에 대한 모든 참조들보다 더 오래 살아있음을 추적합니다.
* 소유권에 대한 주제를 다룰 때 이 빌림에 대해 더 자세히 이야기 하겠습니다.

<details>

<summary>놀미 노트</summary>

*   러스트 컴파일러는 실행시에 가비지 컬렉터처럼 변수들의 참조를 모두 추적합니다. 이 기능 중 하나가 빌리는 관계를 추적하는 것입니다.

    Box처럼 T가 힙에서 할당된 경우는 어떻게 될까요? Box 자체는 힙에 있을 수도 있고 스택에 있을 수도 있습니다. 스택에 있는 경우 T는 힙에 있습니다. 스택 변수들의 연관을 추적해서 소멸하면 Box의 Drop에서 T를 같이 Drop합니다. T의 Drop에서 이후 연결된 메모리들이 같이 해제됩니다.
* 러스트 컴파일러의 추적 기능이 잘 검사를 해주기 때문에 (그래서, 우회하는 코드나 정상적인 코드가 컴파일 안 되는 불편함이 있지만) 허상 참조나 중복 해제 걱정 없이 코딩할 수 있습니다.

</details>
