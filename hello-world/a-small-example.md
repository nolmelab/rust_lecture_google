# 작은 예제 (A small example)

러스트로 작성된 작은 예제입니다:

```rust
fn main() {              // 프로그램 진입점입니다.
    let mut x: i32 = 6;  // 가변 변수 할당(binding)입니다.
    print!("{x}");       // printf와 같은 출력을 위한 매크로 입니다.
    while x != 1 {       // 표현식에 괄호는 없습니다.
        if x % 2 == 0 {  // 다른 언어와 같은 수학연산식이 사용됩니다.
            x = x / 2;
        } else {
            x = 3 * x + 1;
        }
        print!(" -> {x}");
    }
    println!();
}
```

<details>

<summary>발표자 노트</summary>

이 코드는 콜라츠 추측(Collatz conjecture)으로 구현됩니다: 반복문이 언제나 종료될 것이라고 믿지만 증명된 것은 아닙니다. 코드를 수정하고 실행해 보시기 바랍니다.

키 포인트:

* 모든 변수가 컴파일 시 정해진 타입을 가짐을 설명합니다. `i32`를 삭제하여 컴파일러가 타입 추론을 하도록 해 봅니다. `i32`을 `i8`로 변경하여 런타임 오버플로를 유발해 볼 수 있습니다.
* `let mut x`를 `let x`로 수정하여 컴파일 오류에 대해 토론합니다.
* 인자가 포맷 문자열과 일치하지 않는 경우 `print!`에서 컴파일 오류가 발생함을 언급하는 것도 좋습니다.
* 단일 변수보다 복잡한 식을 출려하려면 `{}`을 자리 표시자로 사용하는 방법을 보여 줍니다.
* 학생들에게 표준 라이브러리가 어디 있는지 알려 주고는, `print!`가 지원하는 포맷팅 언어의 문법을 알기 위해 `std::fmt`를 검색해야 한다는 것을 가르치세요.학생들이 표준 라이브러리의 검색 기능에 익숙해 지도록 하는 것이 중요합니다.

</details>

<details>

<summary>놀미 노트</summary>

* 콜라츠 추측은 3n+1 문제라고도 불리는데 매우 단순하면서 아직 증명되지 않아 흥미롭습니다.
* 러스트는 최신의 정적 타잎 시스템을 갖는 다른 언어들처럼 타잎 추론을 매우 잘 합니다.
* let, let mut에 대한 추가 설명은 뒤 쪽에 더 나옵니다. 여기서는 다른 언어와 비교하여 러스트의 코드 모양에 대한 느낌을 알면 될 것 같습니다. 러스트는 C 계열의 문법 스타일을 계승하고 있습니다.
* 러스트 자료도 매우 풍부하게 많습니다. std::fmt 같은 모듈은 검색하면 바로 러스트 문서를 찾을 수 있습니다.

</details>

<details>

<summary>연습</summary>

* [\[Rust By Example : Hello World\]](https://doc.rust-lang.org/rust-by-example/hello.html)를 카고로 만든 프로젝트에서 vscode나 IDE에서 직접 실행해 봅니다.

</details>
