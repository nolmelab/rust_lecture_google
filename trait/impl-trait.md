# 트레이트 구현 (impl Trait)

트레잇 바운드와 유사하게 `impl Trait` 문법은 함수의 인자와 반환값에도 적용 가능합니다:

```rust
use std::fmt::Display;

fn get_x(name: impl Display) -> impl Display {
    format!("Hello {name}")
}

fn main() {
    let x = get_x("foo");
    println!("{x}");
}
```

* impl Trait를 사용하면 이름을 지정할 수 없는 유형으로 작업할 수 있습니다

함수 아규먼트의 `impl Display`는 `where`나 `<T : Display>`와 같다고 했습니다. 반환값도 같은 의미입니다.&#x20;

<details>

<summary>발표자 노트</summary>

`impl Trait`는 어디에 사용되었느냐에 따라 의미가 조금씩 다릅니다.

* 매개변수의 경우, impl Trait는 트레이트가 바인딩된 익명의 일반 매개변수와 같습니다.
* 반환 타잎의 경우 반환 타잎이 타잎 이름을 지정하지 않고 트레이트를 구현하는 구체적인 타잎임을 의미합니다. 이는 공개 API에서 구체적인 유형을 노출하고 싶지 않을 때 유용할 수 있습니다.
* 반환 위치에서는 추론이 어렵습니다. impl Foo를 반환하는 함수는 반환하는 구체적인 유형을 소스에 쓰지 않고 선택합니다. collect\<B>() -> B와 같이 일반 타잎을 반환하는 함수는 B를 만족하는 모든 타잎을 반환할 수 있으며, 호출자는 let x와 같이 하나를 선택해야 할 수 있습니다: Vec<\__> = foo.collect() 또는 터보피쉬의 경우 foo.collect::\<Vec<\__>>().

터보피시는 큰 물고기로 ::\<Type> 형태의 타잎 지정을 의미합니다. ::를 머리로 보면 물고기처럼 보입니다. [터보피시 설명](https://techblog.tonsser.com/posts/what-is-rusts-turbofish)이 잘 되어 있는 블로그입니다.

반환 타잎에 impl Trait를 사용하는 경우는 생각보다 적습니다. 제네릭 아규먼트를 사용하거나 구체적인 타잎을 사용하는 경우가 많습니다. 왜 그럴까요? 아래의 제네릭 타잎 사용이 하나의 답일 수 있습니다.&#x20;

이 예시는 `impl Display`가 두번 사용 되었다는 점에서 훌륭합니다. 여기서 중요한 것은 이 두 `impl Display`가 실제로 같은 타입일 필요가 없다는 것입니다. 만약 `T: Display`로 트레잇 경계를 정하고 입력 파라메터와 리턴 값의 타입을 모두 `T`로 했다면, 이는 입력과 리턴값이 같은 타입임을 강제합니다. 이렇게 했다면 위의 예제는 동작하지 않았을 것입니다. 왜냐하면, 입력 값의 타입이 `format!`이 리턴하는 타입과 같지 않을 가능성이 높기 때문입니다. 만약 `: Display` 문법을 사용하고 싶다면 독립적인 제네릭 매개변수가 두 개가 필요합니다.

</details>

